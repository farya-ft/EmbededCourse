Day 9: Advanced Multi-threading and Synchronization
1. Advanced Multi-threading Techniques
In this lesson, we will focus on more advanced multi-threading concepts, including atomic operations, thread-safe data structures, and thread synchronization using condition variables and barriers.

Atomic Operations

Atomic operations are essential for ensuring data integrity in multi-threaded applications without using locks.

Code: Atomic Operations Example

cpp
Copy code
#include <iostream>
#include <thread>
#include <atomic>
#include <vector>

std::atomic<int> counter(0);

void incrementCounter() {
    for (int i = 0; i < 1000; ++i) {
        ++counter;
    }
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; ++i) {
        threads.emplace_back(incrementCounter);
    }
    for (auto& th : threads) {
        th.join();
    }
    std::cout << "Final counter value: " << counter << std::endl;
    return 0;
}
Explanation:

std::atomic<int> counter(0);: Declares an atomic integer.
++counter;: Atomic increment operation, ensuring thread-safe updates.
Thread-safe Data Structures

Standard containers are not thread-safe. Using synchronization mechanisms, you can create thread-safe wrappers.

Code: Thread-safe Queue Example

cpp
Copy code
#include <iostream>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>

template <typename T>
class ThreadSafeQueue {
public:
    void push(T value) {
        std::lock_guard<std::mutex> lock(mutex_);
        queue_.push(value);
        condition_.notify_one();
    }

    T pop() {
        std::unique_lock<std::mutex> lock(mutex_);
        condition_.wait(lock, [this]{ return !queue_.empty(); });
        T value = queue_.front();
        queue_.pop();
        return value;
    }

private:
    std::queue<T> queue_;
    std::mutex mutex_;
    std::condition_variable condition_;
};

void producer(ThreadSafeQueue<int>& queue) {
    for (int i = 0; i < 10; ++i) {
        queue.push(i);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void consumer(ThreadSafeQueue<int>& queue) {
    for (int i = 0; i < 10; ++i) {
        int value = queue.pop();
        std::cout << "Consumer popped: " << value << std::endl;
    }
}

int main() {
    ThreadSafeQueue<int> queue;
    std::thread prod(producer, std::ref(queue));
    std::thread cons(consumer, std::ref(queue));
    prod.join();
    cons.join();
    return 0;
}
Explanation:

std::lock_guard<std::mutex> lock(mutex_);: Locks the mutex for the duration of the block.
condition_.wait(lock, [this]{ return !queue_.empty(); });: Waits until the queue is not empty.
Barriers

Barriers synchronize a fixed number of threads, making them wait until all threads have reached the barrier.

Code: Barrier Example (Pseudo-code)

cpp
Copy code
#include <iostream>
#include <thread>
#include <barrier>
#include <vector>

std::barrier sync_point(3);

void task(int id) {
    std::cout << "Task " << id << " reached barrier" << std::endl;
    sync_point.arrive_and_wait();
    std::cout << "Task " << id << " passed barrier" << std::endl;
}

int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(task, i);
    }
    for (auto& th : threads) {
        th.join();
    }
    return 0;
}
Explanation:

std::barrier sync_point(3);: Initializes a barrier for 3 threads.
sync_point.arrive_and_wait();: Each thread waits until all threads reach this point.
2. Synchronization Using Condition Variables
Condition variables are used to block one or more threads until a particular condition is met.

Code: Condition Variables Example

cpp
Copy code
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void print_id(int id) {
    std::unique_lock<std::mutex> lck(mtx);
    while (!ready) cv.wait(lck);
    std::cout << "Thread " << id << std::endl;
}

void go() {
    std::unique_lock<std::mutex> lck(mtx);
    ready = true;
    cv.notify_all();
}

int main() {
    std::thread threads[10];
    for (int i = 0; i < 10; ++i) {
        threads[i] = std::thread(print_id, i);
    }

    std::cout << "10 threads ready to race...\n";
    go();

    for (auto &th : threads) th.join();

    return 0;
}
Explanation:

std::condition_variable cv;: Declares a condition variable.
cv.wait(lck);: Waits for the condition variable to be notified.
cv.notify_all();: Notifies all waiting threads.
3. Real-Time Operating Systems (RTOS) - Advanced Features
In this section, we explore more advanced features of RTOS like task priorities, dynamic memory allocation, and inter-task communication.

Task Priorities

RTOS allows setting different priorities for tasks, ensuring critical tasks get more CPU time.

Code: RTOS Task Priorities (Pseudo-code using FreeRTOS)

cpp
Copy code
#include <FreeRTOS.h>
#include <task.h>

void vTaskHighPriority(void *pvParameters) {
    while (1) {
        // High priority task actions
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

void vTaskLowPriority(void *pvParameters) {
    while (1) {
        // Low priority task actions
        vTaskDelay(200 / portTICK_PERIOD_MS);
    }
}

int main() {
    xTaskCreate(vTaskHighPriority, "High Priority Task", 1000, NULL, 2, NULL);
    xTaskCreate(vTaskLowPriority, "Low Priority Task", 1000, NULL, 1, NULL);

    vTaskStartScheduler();

    for (;;);
    return 0;
}
Explanation:

xTaskCreate: Creates tasks with different priorities.
vTaskStartScheduler(): Starts the RTOS scheduler.
Inter-Task Communication

RTOS provides mechanisms like message queues, semaphores, and mailboxes for inter-task communication.

Code: RTOS Message Queue (Pseudo-code using FreeRTOS)

cpp
Copy code
#include <FreeRTOS.h>
#include <task.h>
#include <queue.h>

QueueHandle_t xQueue;

void vProducerTask(void *pvParameters) {
    int value = 0;
    while (1) {
        xQueueSend(xQueue, &value, portMAX_DELAY);
        value++;
        vTaskDelay(100 / portTICK_PERIOD_MS);
    }
}

void vConsumerTask(void *pvParameters) {
    int value;
    while (1) {
        xQueueReceive(xQueue, &value, portMAX_DELAY);
        // Process value
        vTaskDelay(200 / portTICK_PERIOD_MS);
    }
}

int main() {
    xQueue = xQueueCreate(10, sizeof(int));

    if (xQueue != NULL) {
        xTaskCreate(vProducerTask, "Producer", 1000, NULL, 1, NULL);
        xTaskCreate(vConsumerTask, "Consumer", 1000, NULL, 1, NULL);

        vTaskStartScheduler();
    }

    for (;;);
    return 0;
}
Explanation:

xQueueCreate: Creates a message queue.
xQueueSend: Sends a message to the queue.
xQueueReceive: Receives a message from the queue.
Daily Challenge:
Create a thread-safe stack using std::mutex and std::condition_variable.
Implement an atomic counter using std::atomic and demonstrate its use in a multi-threaded context.
Write an RTOS application with tasks of different priorities and implement inter-task communication using message queues.
