Day 7: Smart Pointers and Advanced Multi-threading
1. Smart Pointers
Smart pointers are a feature in C++ that help manage dynamic memory automatically. They prevent memory leaks by ensuring that memory is properly freed when it is no longer needed.

Types of Smart Pointers:

std::unique_ptr: Owns a resource exclusively. No other smart pointer can own the same resource.
std::shared_ptr: Allows multiple smart pointers to share ownership of a resource.
std::weak_ptr: A non-owning reference to an object managed by std::shared_ptr.
Unique Pointer Example

cpp
Copy code
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() {
        std::cout << "MyClass Constructor" << std::endl;
    }
    ~MyClass() {
        std::cout << "MyClass Destructor" << std::endl;
    }
    void display() {
        std::cout << "Displaying MyClass" << std::endl;
    }
};

int main() {
    std::unique_ptr<MyClass> ptr1 = std::make_unique<MyClass>();
    ptr1->display();
    
    // Ownership can be transferred
    std::unique_ptr<MyClass> ptr2 = std::move(ptr1);
    if (ptr1 == nullptr) {
        std::cout << "ptr1 is null after transfer" << std::endl;
    }
    ptr2->display();
    
    return 0;
}
Shared Pointer Example

cpp
Copy code
#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() {
        std::cout << "MyClass Constructor" << std::endl;
    }
    ~MyClass() {
        std::cout << "MyClass Destructor" << std::endl;
    }
    void display() {
        std::cout << "Displaying MyClass" << std::endl;
    }
};

int main() {
    std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>();
    {
        std::shared_ptr<MyClass> ptr2 = ptr1;
        ptr2->display();
        std::cout << "Use count: " << ptr1.use_count() << std::endl;
    }
    std::cout << "Use count after scope: " << ptr1.use_count() << std::endl;
    ptr1->display();
    
    return 0;
}
2. Advanced Multi-threading
Advanced multi-threading techniques can help improve the performance and responsiveness of your applications. These include thread synchronization, thread pooling, and using condition variables.

Mutex and Condition Variable Example

cpp
Copy code
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void print_id(int id) {
    std::unique_lock<std::mutex> lck(mtx);
    while (!ready) cv.wait(lck);
    std::cout << "Thread " << id << std::endl;
}

void go() {
    std::unique_lock<std::mutex> lck(mtx);
    ready = true;
    cv.notify_all();
}

int main() {
    std::thread threads[10];
    for (int i = 0; i < 10; ++i) {
        threads[i] = std::thread(print_id, i);
    }

    std::cout << "10 threads ready to race...\n";
    go();

    for (auto &th : threads) th.join();

    return 0;
}
Explanation:

std::mutex mtx;: Mutex for synchronizing access.
std::condition_variable cv;: Condition variable for synchronization.
cv.wait(lck);: Waits for the condition variable to be notified.
cv.notify_all();: Notifies all waiting threads.
Thread Pool Example (Pseudo-code)

cpp
Copy code
#include <iostream>
#include <vector>
#include <thread>
#include <queue>
#include <functional>
#include <mutex>
#include <condition_variable>

class ThreadPool {
public:
    ThreadPool(size_t threads);
    ~ThreadPool();
    void enqueue(std::function<void()> task);

private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;

    void worker_thread();
};

ThreadPool::ThreadPool(size_t threads) : stop(false) {
    for (size_t i = 0; i < threads; ++i) {
        workers.emplace_back(&ThreadPool::worker_thread, this);
    }
}

ThreadPool::~ThreadPool() {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
    }
    condition.notify_all();
    for (std::thread &worker : workers) {
        worker.join();
    }
}

void ThreadPool::enqueue(std::function<void()> task) {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        tasks.push(task);
    }
    condition.notify_one();
}

void ThreadPool::worker_thread() {
    while (true) {
        std::function<void()> task;
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            condition.wait(lock, [this] { return stop || !tasks.empty(); });
            if (stop && tasks.empty()) return;
            task = std::move(tasks.front());
            tasks.pop();
        }
        task();
    }
}

void exampleTask(int id) {
    std::cout << "Executing task " << id << std::endl;
}

int main() {
    ThreadPool pool(4);
    for (int i = 0; i < 10; ++i) {
        pool.enqueue([i] { exampleTask(i); });
    }
    return 0;
}
Explanation:

ThreadPool(size_t threads);: Constructor that starts the specified number of worker threads.
~ThreadPool();: Destructor that joins all worker threads.
void enqueue(std::function<void()> task);: Enqueues a task for execution.
void worker_thread();: Worker thread function that executes tasks from the queue.
3. Embedded Systems Insight
In embedded systems, using smart pointers can help manage dynamic memory safely, and advanced multi-threading techniques can optimize the performance of real-time tasks.

Embedded Example: Sensor Data Processing with Thread Pool (Pseudo-code)

cpp
Copy code
#include <iostream>
#include <vector>
#include <thread>
#include <queue>
#include <functional>
#include <mutex>
#include <condition_variable>

class ThreadPool {
public:
    ThreadPool(size_t threads);
    ~ThreadPool();
    void enqueue(std::function<void()> task);

private:
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;

    void worker_thread();
};

ThreadPool::ThreadPool(size_t threads) : stop(false) {
    for (size_t i = 0; i < threads; ++i) {
        workers.emplace_back(&ThreadPool::worker_thread, this);
    }
}

ThreadPool::~ThreadPool() {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
    }
    condition.notify_all();
    for (std::thread &worker : workers) {
        worker.join();
    }
}

void ThreadPool::enqueue(std::function<void()> task) {
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        tasks.push(task);
    }
    condition.notify_one();
}

void ThreadPool::worker_thread() {
    while (true) {
        std::function<void()> task;
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            condition.wait(lock, [this] { return stop || !tasks.empty(); });
            if (stop && tasks.empty()) return;
            task = std::move(tasks.front());
            tasks.pop();
        }
        task();
    }
}

class Sensor {
public:
    void readData() {
        std::cout << "Reading sensor data" << std::endl;
    }
};

void processSensorData(int id) {
    Sensor sensor;
    sensor.readData();
    std::cout << "Processing data from sensor " << id << std::endl;
}

int main() {
    ThreadPool pool(4);
    for (int i = 0; i < 10; ++i) {
        pool.enqueue([i] { processSensorData(i); });
    }
    return 0;
}
Explanation:

processSensorData: Function to read and process sensor data.
pool.enqueue([i] { processSensorData(i); });: Enqueues sensor data processing tasks.
Daily Challenge:
Create a SensorManager class that uses std::shared_ptr to manage multiple sensor objects.
Implement a thread pool in the SensorManager to read and process data from multiple sensors concurrently.
Add error handling to the SensorManager to manage sensor read errors.